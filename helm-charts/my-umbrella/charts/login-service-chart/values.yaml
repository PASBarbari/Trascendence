# Default values for login-service-chart.
replicaCount: 1

image:
  repository: bombatomica/login # Changed from nginx to your login service image
  pullPolicy: Always # Changed from IfNotPresent, align with chat service
  tag: latest # Or specify a version

nameOverride: ""
fullnameOverride: ""

namespace: login

service:
  type: ClusterIP # Changed from LoadBalancer (manual manifest) to ClusterIP, common for internal services
  port: 8000 # Port the service will expose
  targetPort: 8000 

serviceAccount:
  name: "trascendence-login-sa"
  dbName: "login-db-service-account"
  create: true
  annotations: {}
  automount: true
  dbAnnotations: {}
  dbAutomount: true

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi


podAnnotations: {}
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000


ingress:
  enabled: true # Assuming you want ingress, similar to chat service
  className: traefik # Your ingress controller class
  annotations: {}
  host: trascendence.42firenze.it # Example host, adjust as needed
  path: /api/login(/|$)(.*)
  pathType: ImplementationSpecific
  tls:
    enabled: true # Enable TLS, similar to chat service
    secretName: login-tls # Name of the TLS secret, ensure this matches your cert-manager setup
    hosts:
      - trascendence.42firenze.it # Must match ingress.host
  certManager: # Corrected indentation: certManager is a direct child of ingress
    clusterIssuer: letsencrypt-prod

autoscaling:
  enabled: true
  minReplicas: 1
  maxReplicas: 1
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80
# Liveness and Readiness Probes
# Adjust paths and ports as per your application's health endpoints
# livenessProbe:
#   httpGet:
#     path: /health # Example, replace with your actual health check endpoint
#     port: http # Refers to the containerPort name 'http'
#   initialDelaySeconds: 30
#   periodSeconds: 20
#   failureThreshold: 3

# readinessProbe:
#   httpGet:
#     path: /health # Example, replace with your actual health check endpoint
#     port: http # Refers to the containerPort name 'http'
#   initialDelaySeconds: 15
#   periodSeconds: 10
#   failureThreshold: 3


# Non-sensitive configurations that will go into a ConfigMap
# These keys will be available as environment variables in your container
configMap:
  data:
    DEBUG: "False"
    DJANGO_SETTINGS_MODULE: "login.settings" # Adjust if your settings module is different
    LOGIN_PORT: "8000" # Port the application inside the container listens on
    LOGIN_HOST: "0.0.0.0" # Host the application binds to
    # Database connection details (host and port)
    # DB_HOST should point to your PostgreSQL service name.
    # If using the 'db' subchart below, it might be "{{ .Release.Name }}-postgresql"
    POSTGRES_HOST: "trascendence-login-db-service" # Use the actual service name
    POSTGRES_PORT: "5432" # Default PostgreSQL port
    # URLs for service discovery - these are examples, adjust hostnames and ports
    # Consider using .Release.Name for service names if deployed by the same umbrella chart
    LOGIN_URL: "http://trascendence-login-service:8000" # Self-referential or external URL
    CHAT_URL: "http://trascendence-chat-service:8000"
    USER_URL: "http://user-service:8002"
    NOTIFICATIONS_URL: "http://notifications-service:8003"
    PONG_URL: "http://pong-service:8004"
    ALLOWED_HOSTS: "*" # Be more specific in production

# Sensitive configurations that will go into a Secret
# The keys here (DB_NAME, DB_USER, etc.) are defined in your secret.yaml template
# The actual values will be base64 encoded by the template.
secrets:
  database:
    name: "placeholder_login_db_name" # e.g., login_db
    user: "placeholder_login_db_user"
    password: "placeholder_login_db_password"
  admin:
    username: "placeholder_admin_username"
    password: "placeholder_admin_password"
    email: "admin@example.com"
    secretKey: "placeholder_django_secret_key"
  servicePassword: "123" # This is the service password used for internal communication, not sensitive
  # API keys for OAuth providers, matching your secret.yaml structure
  apiKeys:
    google:
      clientId: "placeholder_google_client_id"
      clientSecret: "placeholder_google_client_secret"
    fortytwo: # 'fortytwo' to match secret.yaml key
      clientId: "placeholder_42_client_id"
      clientSecret: "placeholder_42_client_secret"

# PostgreSQL subchart configuration (optional, if you want this chart to deploy its own DB)
# If you use an external DB, you can remove or disable this 'db' section
# and ensure DB_HOST, DB_USER, DB_NAME, DB_PASSWORD are correctly set for the external DB.
db:
  enabled: true # Set to true to deploy PostgreSQL along with the login service
  image:
    repository: postgres
    tag: "13" # Specify your desired postgres version
    pullPolicy: IfNotPresent
  service:
    port: 5432
  resources:
    limits:
      cpu: "1"
      memory: "1Gi"
    requests:
      cpu: "250m"
      memory: "256Mi"
  persistence:
    enabled: true
    storageClass: "" # Optional: If blank, uses default SC. Set to "-" to disable SC.
    size: "1Gi"
    annotations: {}
  # PostgreSQL specific environment variables for the subchart
  # These are used to initialize the PostgreSQL instance if db.enabled is true.
  # The login application itself will use the values from .Values.secrets.database.*
  postgresqlUsername: "" # Will default to .Values.secrets.database.user if not set and db.enabled=true
  postgresqlPassword: "" # Will default to .Values.secrets.database.password if not set and db.enabled=true
  postgresqlDatabase: "" # Will default to .Values.secrets.database.name if not set and db.enabled=true

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

nodeSelector: {}
tolerations: []
affinity: {}